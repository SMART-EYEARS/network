# 📚 들어가면서 
**네트워크 계층**에서 다른 네트워크로 데이터를 전송하는 데에는 **라우터**가 필요하다   
라우터의 라우팅 기능을 이용하여 데이터를 전송할 때,   

* 라우팅 정보가 잘못되었다.    
* 많은 라우터를 경유하는 도중에 라우터에 문제가 생겼다.    
* 패킷이 손상되었다.     
  
위와 같은 문제들로 인하여, **패킷이 손상되면 데이터가 수신지에 도착하지 못할 수 있다.**      
   
**`물리`**`+`**`데이터링크`**`+`**`네트워크`** 를 이용하면 데이터를 전송할 수 있다.     
하지만, **전송중인 데이터가 손상되거나 분실되면 아무런 후속 작업을 해줄 수 없다.**       

# 📕 전송 계층     
전송 계층은 **수신지에 신뢰할 수 있는 데이터를 전송하기 위해 필요한 계층이다.**     
전송 계층은 **`오류를 점검하는 기능을 가지고 있기 때문에`**      
데이터에 오류가 발생하면 **송신측에 재 전송을 요청할 수 있다.**    
        
쉽게 설명하면, **`물리`**`+`**`데이터링크`**`+`**`네트워크`** 까지는 데이터를 전송,              
**전송 계층**은 데이터가 제대로 도착했는지 확인할 수 있다. 
      
그리고 전송 계층은 **전송된 데이터가 어떤 Application에서 사용되는지 확인도 가능하다.**                        
정확히 말하면, 수신된 데이터가 어떤 응용 프로그램에서 사용하는 것인지 판단해야한다.         
예를 들면, `웹 페이지에서 사용하는 데이터`가 오면 이를 `크롬`과 같은 브라우저에 알려줘야하기 때문이다.      
   
___   
     
전송 계층은 TCP/UDP와 관련도니 계층으로 **오류 복구**와 **흐름제어**를 담당하며    
두 시스템 간에 **신뢰성 있는 데이터를 전송하기 위해 존재**한다.   
(그렇기 때문에, 단순히 **전송**만 하는 라우터는 네트워크 계층(3계층)이다.)               
   
또한, 수신시에는 **세션 계층의 어느 애플리케이션에 보낼지 판단**하고,      
손신시에는 네트워크 계층으로 전송할 경로를 선택한다.     

시스템 종단 간에 **투명한 데이터를 양방향으로 전송**하는 계층으로,   
네트워크 계층에서 전송한 데이터와 실제 운영체제의 프로그램이 연결되는 통신경로라 볼 수 있다.   
**`네트워크`** `<-전송계층->` **`실제 OS 프로그램`**   

  
|역할|개념|주요 기술|  
|---|----|---------|   
|종단간 연결|-종단 간 에러 없이 메시지 전송 연결 제공|– 에러 여부 확인<br>-3way-handshake|
|서비스지점<br>주소 지정|– Port 이용하여 프로세스 통신 제공 기능|– 송수신 포트 주소<br>– ftp(21), http(80) 등|
|다중화<br>역다중화|– 세그먼트 통합 및 전송, 적절한 port로 배분|– MUX, DEMUX 활용<br>– Header 정보 기반|  
|분할<br>재조립|– 메시지를 세그먼트 단위 분할, 순서대로 재조립|-세그먼트 순서정보<br>– 손실 패킷 발견|   
            
필히 참고 바람 : http://blog.skby.net/%EC%A0%84%EC%86%A1-%EA%B3%84%EC%B8%B5-transport-layer/     
 
# 📗 TCP
TCP는 **`연결지향형 프로토콜`** 로 **신뢰성 있는 바이트 스트림 서비스를 제공한다.**   
      
**연결지향**      
응용 프로그램이 데이터를 교환하기 전에 서로 TCP 연결을 확립해야한다.     
      
**신뢰성**   
데이터를 성공적으로 수신했거나 오류가 발생했음을 알려주는 것     
   
즉, 상호간에 네트워크 연결 합의하에 데이터를 보내고, 성공적으로 수신할 때까지 재 전송해준다.        

## 📖 TCP 연결형 데이터 서비스    
* `데이터 전송 서비스`는     
두 통신 프로세스간에 **양방향**으로 동시에 데이터를 전송할 수 있는 **이중 방식 서비스를 말한다.**         
       
* `연결 지향형 프로토콜`은   
송수신측 컴퓨터가 **데이터를 전송하기 전**에        
먼저 **데이터를 송수신할 수 있는 열결 통로를 만들고 데이터를 전송**하는 프로토콜이다.        
이후 연결 상태를 확인하고 데이터를 전송하고 통신을 종료할 때 까지, 연결 상태를 유지한다.       
또한, **데이터가 잘 전송되었는지 확인하여 신뢰성 있는 데이터 전송을 보장한다.**     
TCP는 대표적인 연결 지향형 프로토콜이다.    

## 📖 포트번호    
포트가 뜬금없이 왜나왔지? 🤔 라고 생각할 수 있지만,      
포트는 **TCP가 상위 계층으로 데이터를 전송하거나**         
**상위 계층에서 TCP로 데이터를 전송할 때 상호간에 사용하는 데이터의 이동 통로를 말한다.***    

```
여기서 말하는 상위 계층인란 건 잘 모르겠습니다. 
```

추가로, **상위 계층 프로토콜과 하위 계층 프로토콜이 같은 포트를 사용해야만 한다.**           
즉, 접속할 때 요청하는 포트 번호는 송신자와 수신자의 포트 번호임을 알 수 있다.      
  
데이터를 전송할 때는, 수신 측의 IP 주소가 필요하지만,      
**어떤 애플리케이션이 사용되고 있는지 구분하려면 TCP는 포트 번호가 필요하다.**    

## 📖 TCP 세그먼트   
![tcp segment](https://user-images.githubusercontent.com/50267433/106351089-4a7f7300-631d-11eb-92eb-8e3e6ec0a9f3.PNG)    
     
TCP 프로토콜은 전송을 위해 바이트 스트림을 세그먼트 단위로 나눈다. (세그먼트는 고정된 크기)            
**세그먼트**는 TCP를 이용하여 두 장치간에 **전달하는 데이터의 단위**를 말한다.         
   
TCP로 데이터를 전송하면, **TCP 데이터에 TCP 헤더가 붙고**, 이를 **TCP 세그먼트**라 부른다.       
     
![tcp header](https://user-images.githubusercontent.com/50267433/106352219-78b48100-6324-11eb-8295-15ece6ca1518.PNG)    
  
TCP 헤더에는 실제 데이터를 보조해주는 다양한 정보들이 있다.       
    
* 송신지 포트 번호 16bit
* 수신지 포트 번호 16bit
* 순서 번호 32bit
* 확인 응답 번호 32bit
* 헤더 길이 4bit
* 예약 6bit
* **코드 비트 6bit**
* 검사합 비트 16bit
* 윈도우 크기 1bit
* 긴급 포인터 16bit
* 옵션, 패딩       
       
여기서 나머지 내용들은 생략하고 가장 중요한 **코드 비트를 설명**하려 한다.        

### 📄 코드 비트     
코드 비트는 TCP 헤더의 107-112번째 비트로, **연결 제어 정보가 기록되어 있는 비트다.**    
107-112비트까지, 총 6개로 비트별로 역할이 정해져 있다.        
공통적으로 비트의 초기값은 0이고, 활성화 되면 1의 값을 가진다.(비트니까..)   
   
데이터를 전송할 때 연결을 확립하려면   
   
* **SYN :** 연결을 요청하는 비트    
* **ACK :** 확인을 응답하는 비트가 필요하다.     
 
|코드 비트|설명|      
|--------|----|  
|URG|긴급하게 처리할 데이터가 들어 있음|   
|URG|응답 확인 번호 사용|    
|PSH|TCP가 받은 데이터를 상위 계층에 전달|    
|RST|연결 재설정|    
|SYN|연결을 초기화하려고 순서 번호 동기화|     
|FIN|데이터 송신 종료|        
  

### 📄 TCP 3-way Handshake
TCP 3 Way Handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에     
먼저 **정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정**을 의미한다.      
        
![99087C405C18E3CD28](https://user-images.githubusercontent.com/50267433/106351397-510eea00-631f-11eb-9a78-4e0706ba2439.png)   
* 이미지 출처 : https://sjlim5092.tistory.com/35

1. 클라이언트 -> 서버 : **연결 요청 패킷** SYN(a) 전송          
2. 서버 -> 클라이언트 : SYN(a) 받고, **연결 요청 응답 패킷** ACK(a+1)와 SYN(b) **연결 요청 패킷** 전송          
3. 클라이언트 -> 서버 : ACK(a+1)와 SYN(b) 받고, **연결 요청 응답 패킷** ACK(b+1) 을 전속하면 연결이 성립됩니다.         
         
```       
1. 클라이언트 : 너 내 말 들리니 syn    
2. 서버 : 응 들려 ack 너도 내말 들리니 syn    
3. 클라이언트 : 응 들려 ack    
```   
    
### 📄 TCP 4-way Handshake    
TCP 4-Way handshake는 두 시스템(컴퓨터)간에 연결된 세션을 종료하기 위해 수행되는 절차이다.               
   
![99229C485C1D90C038](https://user-images.githubusercontent.com/50267433/106351474-bf53ac80-631f-11eb-82f5-186af286aa2b.png)     
 * 이미지 출처 : https://sjlim5092.tistory.com/35  
   
1. 클라이언트 -> 서버 : 연결 종료를 의미하는 **FIN 플래그** 전송        
2. 서버 -> 클라이언트 : FIN 플래그 받고 **확인 패킷 ACK 전송**        
3. 그리고 데이터를 모두 보낼때까지 잠깐 TIME_OUT      
4. 서버 -> 클라이언트 : 데이터 모두 보내고 통신이 끝났으면 연결 종료 **FIN 플래그** 전송     
5. 클라이언트 -> 서버 : FIN 메시지 확인후 **확인 패킷 ACK 전송**      

```
1. 클라이언트 : 나 이제 종료할게 FIN
2. 서버 : 응 알겠어 ACk
3. 서버 : 그래도 데이터 다 보낼때까지는 잠시 대기할게 
4. 서버 : 나도 이제 통신 끝냈어 종료할게 FIN   
5. 클라이언트 : 응, 알겠어 ACK (그래도 서버에서 아직 안 온 데이터 있을까봐 잠시 대기)   
```


* 서버 : 클라이언트의 ACK를 받으면 **소켓 연결 CLOSE**          
* 클라이언트 : 서버로부터 아직 받지 못한 데이터 대비해 일정시간 동안 대기 TIME_OUT         

# 📘 UDP
UPD는 RFC 768 문서에 정의된 비연결 지향형 프로토콜로,   
**패킷이나 흐름제어, 단편화 및 전송보장등의 기능을 `제공하지 않는다.`**    
     
UDP 헤더는 TCP헤더에 비해, 간단하기 때문에 상대적으로 통신 과부하가 적다.         
크기만 비교해보더라도 UDP는 8바이트, TCP는 20바이트로 차이가 많이난다.            
그렇기에 데이터 전송이 비교적 빨라서 실시간 데이터 전송에 많이 사용된다.(스트리밍 서비스)   
       
UDP는 연결을 위한 **독립적인 제어 메시지 패킷을 사용하지 않는다.**      
UDP는 오로지, **요청 메시지와 응답 메시지로 구성되며** 주로 적은 양의 데이터 전송에 사용된다.     
(사실, 데이터를 많이 보내면 속도보다는 안정성이 중요하므로 TCP를 사용하는 것이 옳다.)   
UDP를 사용하는 대표적인 응용 계층 프로토콜은 DNS/DHCP/SNMP 등이 있다.   
   
![upd header](https://user-images.githubusercontent.com/50267433/106352114-09d72800-6324-11eb-90fc-bd769db80f74.PNG)     
    
UDP는 비연결형 서비스이고 데이터 전송의 신뢰성을 확보할 수 없기 때문에,       
네트워크에서 사용하기에 부적절하다고 생각할 수도 있다.          
    
그러나, 신뢰성을 확보하기 위한 부가적인 정보가 필요없으므로      
**전송 데이터의 양이 적을 때 TCP보다 전송 속도가 더 빠르다.**        
또한 상위 계층에 신뢰성을 보장하는 프로토콜이 있거나 인터넷 방송의 멀티미디어 데이터 전송처럼      
**정확성보다는 전송 속도가 더 중요할 때 유용하다.**          

# 🤜🤛TCP와 UDP의 비교
**TCP**   
`TCP(Transmission Control Protocol, 전송제어 프로토콜)` :   
* **연결형 전송 프로토콜**로서 신뢰성 과 안정성을 보장해준다.     
* TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. -> 가상 회선      
* TCP 에서 연결 설정(connection establishment)는 `3-way handshake`를 통해 행해진다.     
     
모든 TCP 연결은 전이중(full-duplex), 점대점(point to point)방식이다.           
전송이 양방향으로 동시에 일어나며 각 연결이 정확히 2 개의 종단점을 가지고 있다.                  
    
TCP 는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.         
    
**UDP**     
`UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)`       
* **비연결형 전송 프로토콜** 로서 속도가 빠르나 신뢰성과 안정성을 보장해주지는 않는다. (재전송 x)       
  
`UDP`를 사용한 것들에는 `DNS`가 있다.        
사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다.       
    
  
